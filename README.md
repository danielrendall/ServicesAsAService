# Services as a Service

Your boss stomps into the room. "We need microservices!" he shouts.

You are slightly surprised by this. "But..." you begin, but he ignores you and
continues:

"No buts. We need microservices and we need them now!"

"But...?" you try again.

"I read a thing on the internet. It told me that all our competitors are being
agile and using microservices in their supply chains and production pipelines
and that we are stuck in the mud and not using microservices and everyone is 
laughing at us. So I order you to install some microservices RIGHT NOW!"

"But...?"

"EVERYONE else is using microservices. We are not and it is making us look like
chumps, and there's no place for chumps in this business. Install them! Now!"

You try again to get a word in edgeways. "But boss, this is a bakery! We don't
have an agile supply chain, we have me mixing stuff in a bowl and putting it in
the oven! We don't need microservices!"

"WE NEED MICROSERVICES! The internet said so! The internet is never wrong! So
install some damn microservices!"

"On what...?" you ask. "This is a bakery!"

The boss gestures wildly in the direction of the cash register. "On that!" he
shouts and stomps out of the room.

So - you need to placate your boss by installing some microservices on a cash
register. I can't help you with the cash register; maybe you can install Linux
on it? I [googled](https://www.google.com/search?q=installing+linux+on+a+cash+register)
and found [this](http://27.org/linuxregister/) - hth. But if you want to install
a microservice but don't know why or what for, other than it will fill a nice
space on someone's complicated architectural diagram, you have come to the right
place.

## What on earth is "services as a service"?

Services-as-a-service (I can't decide whether I like it hyphenated or not) is a
really simple application server skeleton. You can install microservice
applications to it by uploading them with something like `curl` (literally -
you make a PUT request whose body is a suitable JAR file) and they will then run
on whatever path you specify.

This sounds a bit like remote code execution, doesn't it? Well, it is. This is
totally about uploading code to a server and having it run, so the very first
principle here is that you should know what you are doing, and not do anything
really silly like running it somewhere open to the internet.

## Why did you write this? Are there any actual use cases for it?

The main use case is to be able to write code to process files in ~~Java~~ 
Scala, and to have an easy way to call it from a Bash script without incurring 
the start-up time of the JVM. In the specific case that originated this, there
was a need to be able to process a large number of separate files with XSLT
(ideally version 2, which rules out `xsltproc`). Writing a wrapper around
Saxon-HE with a webserver seemed simple enough, but then I had the cunning idea
that instead of embedding the XSLT I wanted in the application resources, I
could POST the XSLTs I wanted it to run at runtime, giving each a name that I
could use in subsequent requests that POSTed XML to be processed. This turned
out to be extremely useful, since it was then trivial to make changes to the
XSLTs, and to add additional XSLTs to do other processing.

There was then a requirement to generate Excel spreadsheets based on reports
generated by running XSLT over various XML files, all running as part of an
XProc pipeline. Since the only thing XProc deals with is XML, I realised that
this could be done by generating XML representations of the spreadsheets in
the pipeline and post-processing with a converter based on Apache POI. It
seemed convenient to do this in the same way - have a webserver to run the
transformation, POST files to it and have it return the .xlsx file to be saved.
Rather than copy and paste all the webserver code and then hacking it to do the
required Excel conversion, I thought it would be more fun to build a generic
server (this project) and tell it what services to use at runtime by POSTing
suitable JARs - thus the same server could be told to run XSLT transformations
and Excel transformations. Start it up in the Bash script, ensure it gets shut
down at the end, and you've got a nice simple tool to run these kinds of
conversion jobs.

## Status

TODO -
* Create GitHub repos for all of the other dependencies of this (this won't
actually do anything on its own!)
* Write some actual documentation...
